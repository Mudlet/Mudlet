<html><head><title>zziplib Library Functions</title>
</head><body>
<h2>zziplib Library Functions</h2><p>Version 0.13.62</p><p><big><b><code>#include &lt;zzip/lib.h&gt;</code></b></big></p><table width="100%"><tr><td valign="top"><code><b><code><a href="#zzip_error">zzip_error</a></code></b>(ZZIP_DIR * dir)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_seterror">zzip_seterror</a></code></b>(ZZIP_DIR * dir, int errcode)  : void
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_open">zzip_open</a></code></b>(zzip_char_t * filename, int o_flags)
 : ZZIP_FILE *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_open_ext_io">zzip_open_ext_io</a></code></b>(zzip_char_t * filename, int o_flags, int o_modes,
                 zzip_strings_t * ext, zzip_plugin_io_t io)
 : ZZIP_FILE *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_open_shared_io">zzip_open_shared_io</a></code></b>(ZZIP_FILE * stream,
                    zzip_char_t * filename, int o_flags, int o_modes,
                    zzip_strings_t * ext, zzip_plugin_io_t io)
 : ZZIP_FILE *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_opendir">zzip_opendir</a></code></b>(zzip_char_t * filename)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_opendir_ext_io">zzip_opendir_ext_io</a></code></b>(zzip_char_t * filename, int o_modes,
                    zzip_strings_t * ext, zzip_plugin_io_t io)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_file_real">zzip_file_real</a></code></b>(ZZIP_FILE * fp)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_dir_real">zzip_dir_real</a></code></b>(ZZIP_DIR * dir)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_realdir">zzip_realdir</a></code></b>(ZZIP_DIR * dir)
 : void *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_realfd">zzip_realfd</a></code></b>(ZZIP_FILE * fp)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_tell">zzip_tell</a></code></b>(ZZIP_FILE * fp)
 : zzip_off_t
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_tell32">zzip_tell32</a></code></b>(ZZIP_FILE * fp)
 : long
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_dir_stat">zzip_dir_stat</a></code></b>(ZZIP_DIR * dir, zzip_char_t * name, ZZIP_STAT * zs, int flags)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_file_stat">zzip_file_stat</a></code></b>(ZZIP_FILE * file, ZZIP_STAT * zs)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_fstat">zzip_fstat</a></code></b>(ZZIP_FILE * file, ZZIP_STAT * zs)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_strerror">zzip_strerror</a></code></b>(int errcode)
 : zzip_char_t *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_strerror_of">zzip_strerror_of</a></code></b>(ZZIP_DIR * dir)
 : zzip_char_t *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_dir_open">zzip_dir_open</a></code></b>(zzip_char_t * filename, zzip_error_t * e)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_dir_open_ext_io">zzip_dir_open_ext_io</a></code></b>(zzip_char_t * filename, zzip_error_t * e,
                     zzip_strings_t * ext, zzip_plugin_io_t io)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_dir_read">zzip_dir_read</a></code></b>(ZZIP_DIR * dir, ZZIP_DIRENT * d)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_init_io">zzip_init_io</a></code></b>(zzip_plugin_io_handlers_t io, int flags)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_get_default_io">zzip_get_default_io</a></code></b>(void)
 : zzip_plugin_io_t
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_rewinddir">zzip_rewinddir</a></code></b>(ZZIP_DIR * dir)
 : void
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_telldir">zzip_telldir</a></code></b>(ZZIP_DIR * dir)
 : zzip_off_t
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_seekdir">zzip_seekdir</a></code></b>(ZZIP_DIR * dir, zzip_off_t offset)
 : void
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_telldir32">zzip_telldir32</a></code></b>(ZZIP_DIR * dir)
 : long
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_seekdir32">zzip_seekdir32</a></code></b>(ZZIP_DIR * dir, long offset)
 : void
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_fopen">zzip_fopen</a></code></b>(zzip_char_t * filename, zzip_char_t * mode)
 : ZZIP_FILE *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_freopen">zzip_freopen</a></code></b>(zzip_char_t * filename, zzip_char_t * mode, ZZIP_FILE * stream)
 : ZZIP_FILE *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_dirhandle">zzip_dirhandle</a></code></b>(ZZIP_FILE * fp)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_dirfd">zzip_dirfd</a></code></b>(ZZIP_DIR * dir)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_seek">zzip_seek</a></code></b>(ZZIP_FILE * fp, zzip_off_t offset, int whence)
 : zzip_off_t
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_seek32">zzip_seek32</a></code></b>(ZZIP_FILE * fp, long offset, int whence)
 : long
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_read">zzip_read</a></code></b>(ZZIP_FILE * fp, void *buf, zzip_size_t len)
 : zzip_ssize_t
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_fread">zzip_fread</a></code></b>(void *ptr, zzip_size_t size, zzip_size_t nmemb, ZZIP_FILE * file)
 : zzip_size_t
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_dir_free">zzip_dir_free</a></code></b>(ZZIP_DIR * dir)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_dir_close">zzip_dir_close</a></code></b>(ZZIP_DIR * dir)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_fclose">zzip_fclose</a></code></b>(ZZIP_FILE * fp)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_close">zzip_close</a></code></b>(ZZIP_FILE * fp)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_dir_fdopen">zzip_dir_fdopen</a></code></b>(int fd, zzip_error_t * errcode_p)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_dir_fdopen_ext_io">zzip_dir_fdopen_ext_io</a></code></b>(int fd, zzip_error_t * errcode_p,
                       zzip_strings_t * ext, const zzip_plugin_io_t io)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_dir_alloc_ext_io">zzip_dir_alloc_ext_io</a></code></b>(zzip_strings_t * ext, const zzip_plugin_io_t io)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_dir_alloc">zzip_dir_alloc</a></code></b>(zzip_strings_t * fileext)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_readdir">zzip_readdir</a></code></b>(ZZIP_DIR * dir)
 : ZZIP_DIRENT *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_closedir">zzip_closedir</a></code></b>(ZZIP_DIR * dir)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_errno">zzip_errno</a></code></b>(int errcode)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_file_close">zzip_file_close</a></code></b>(ZZIP_FILE * fp)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_file_open">zzip_file_open</a></code></b>(ZZIP_DIR * dir, zzip_char_t * name, int o_mode)
 : ZZIP_FILE *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_inflate_init">zzip_inflate_init</a></code></b>(ZZIP_FILE * fp, struct zzip_dir_hdr *hdr)
 : static int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_file_read">zzip_file_read</a></code></b>(ZZIP_FILE * fp, void *buf, zzip_size_t len)
 : zzip_ssize_t
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_rewind">zzip_rewind</a></code></b>(ZZIP_FILE * fp)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#zzip_compr_str">zzip_compr_str</a></code></b>(int compr)
 : zzip_char_t *
</code></td></tr><tr><td valign="top"><code><b><code><a href="#__zzip_fetch_disk_trailer">__zzip_fetch_disk_trailer</a></code></b>(int fd, zzip_off_t filesize,
                          struct _disk_trailer *_zzip_restrict trailer,
                          zzip_plugin_io_t io)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#__zzip_parse_root_directory">__zzip_parse_root_directory</a></code></b>(int fd,
                            struct _disk_trailer *trailer,
                            struct zzip_dir_hdr **hdr_return,
                            zzip_plugin_io_t io)
 : int
</code></td></tr><tr><td valign="top"><code><b><code><a href="#__zzip_try_open">__zzip_try_open</a></code></b>(zzip_char_t * filename, int filemode,
                zzip_strings_t * ext, zzip_plugin_io_t io)
 : int
</code></td></tr></table><h3>Documentation</h3><dl><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_error">zzip_error</a></b>(ZZIP_DIR * dir)
 : int
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_seterror">zzip_seterror</a></b>(ZZIP_DIR * dir, int errcode)  : void
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/info.c</small></em></td></table>
</td></tr><tr><td valign="top"><p>   The <code>zzip_seterror</code> function just does dir->errcode = errcode
</p>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_open">zzip_open</a></b>(zzip_char_t * filename, int o_flags)
 : ZZIP_FILE *
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_open_ext_io">zzip_open_ext_io</a></b>(zzip_char_t * filename, int o_flags, int o_modes,
                 zzip_strings_t * ext, zzip_plugin_io_t io)
 : ZZIP_FILE *
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_open_shared_io">zzip_open_shared_io</a></b>(ZZIP_FILE * stream,
                    zzip_char_t * filename, int o_flags, int o_modes,
                    zzip_strings_t * ext, zzip_plugin_io_t io)
 : ZZIP_FILE *
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/file.c</small></em></td></table>
</td></tr><tr><td valign="top"><p>
  The <code>zzip_open_ext_io</code> function uses explicit ext and io instead of the internal
  defaults, setting them to zero is equivalent to <code><a href="#zzip_open">zzip_open</a></code>
</p><p>
  note that the two flag types have been split into an o_flags
  (for fcntl-like openflags) and o_modes where the latter shall
  carry the zzip_flags and possibly accessmodes for unix filesystems.
  Since this version of zziplib can not write zipfiles, it is not
  yet used for anything else than zzip-specific modeflags.
</p><p>
  The <code>zzip_open_ext_io</code> function returns a new zzip-handle (use <code><a href="#zzip_close">zzip_close</a></code> to return
  it). On error the <code>zzip_open_ext_io</code> function will return null setting <a href="http://www.opengroup.org/onlinepubs/000095399/functions/errno.html"><code>errno(3)</code></a>.
</p><p>
  If any ext_io handlers were used then the referenced structure
  should be static as the allocated ZZIP_FILE does not copy them.
</p>
</td></tr><tr><td valign="top"><p>
  The <code>zzip_open_shared_io</code> function takes an extra stream argument - if a handle has been
  then ext/io can be left null and the new stream handle will pick up
  the ext/io. This should be used only in specific environment however
  since <code><a href="#zzip_file_real">zzip_file_real</a></code> does not store any ext-sequence.
</p><p>
  The benefit for the <code>zzip_open_shared_io</code> function comes in when the old file handle
  was openened from a file within a zip archive. When the new file
  is in the same zip archive then the internal zzip_dir structures
  will be shared. It is even quicker, as no check needs to be done
  anymore trying to guess the zip archive place in the filesystem,
  here we just check whether the zip archive's filepath is a prefix
  part of the filename to be opened.
</p><p>
  Note that the <code>zzip_open_shared_io</code> function is also used by <code><a href="#zzip_freopen">zzip_freopen</a></code> that
  will unshare the old handle, thereby possibly closing the handle.
</p><p>
  The <code>zzip_open_shared_io</code> function returns a new zzip-handle (use <code><a href="#zzip_close">zzip_close</a></code> to return
  it). On error the <code>zzip_open_shared_io</code> function will return null setting <a href="http://www.opengroup.org/onlinepubs/000095399/functions/errno.html"><code>errno(3)</code></a>.
</p>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_opendir">zzip_opendir</a></b>(zzip_char_t * filename)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_opendir_ext_io">zzip_opendir_ext_io</a></b>(zzip_char_t * filename, int o_modes,
                    zzip_strings_t * ext, zzip_plugin_io_t io)
 : ZZIP_DIR *
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/dir.c</small></em></td></table>
</td></tr><tr><td valign="top"><p>  The <code>zzip_opendir_ext_io</code> function uses explicit ext and io instead of the internal 
  defaults, setting them to zero is equivalent to <code><a href="#zzip_opendir">zzip_opendir</a></code>
</p>
</td></tr></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_file_real">zzip_file_real</a></b>(ZZIP_FILE * fp)
 : int
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_dir_real">zzip_dir_real</a></b>(ZZIP_DIR * dir)
 : int
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_realdir">zzip_realdir</a></b>(ZZIP_DIR * dir)
 : void *
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_realfd">zzip_realfd</a></b>(ZZIP_FILE * fp)
 : int
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/info.c</small></em></td></table>
</td></tr><tr><td valign="top"><p>  The <code>zzip_dir_real</code> function checks if the ZZIP_DIR-handle is wrapping
  a real directory or a zip-archive.
  Returns 1 for a stat'able directory, and 0 for a handle to zip-archive.
</p>
</td></tr><tr><td valign="top"><p>  The <code>zzip_realdir</code> function returns the posix DIR* handle (if one exists).
  Check before with <code><a href="#zzip_dir_real">zzip_dir_real</a></code> if the
  the ZZIP_DIR points to a real directory.
</p>
</td></tr><tr><td valign="top"><p>  The <code>zzip_realfd</code> function returns the posix file descriptor (if one exists).
  Check before with <code><a href="#zzip_file_real">zzip_file_real</a></code> if the
  the ZZIP_FILE points to a real file.
</p>
</td></tr></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_tell">zzip_tell</a></b>(ZZIP_FILE * fp)
 : zzip_off_t
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_tell32">zzip_tell32</a></b>(ZZIP_FILE * fp)
 : long
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/file.c</small></em></td></table>
</td></tr><tr><td valign="top"><p>  The <code>zzip_tell32</code> function is provided for users who can not use any largefile-mode.
</p>
</td></tr></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_dir_stat">zzip_dir_stat</a></b>(ZZIP_DIR * dir, zzip_char_t * name, ZZIP_STAT * zs, int flags)
 : int
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_file_stat">zzip_file_stat</a></b>(ZZIP_FILE * file, ZZIP_STAT * zs)
 : int
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_fstat">zzip_fstat</a></b>(ZZIP_FILE * file, ZZIP_STAT * zs)
 : int
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/stat.c</small></em></td></table>
</td></tr><tr><td valign="top"><p>  The <code>zzip_file_stat</code> function will obtain information about a opened file _within_ a 
  zip-archive. The file is supposed to be open (otherwise -1 is returned). 
  The st_size stat-member contains the uncompressed size. The optional 
  d_name is never set here. 
</p>
</td></tr><tr><td valign="top"><p>  The <code>zzip_fstat</code> function will obtain information about a opened file which may be
  either real/zipped. The file is supposed to be open (otherwise -1 is 
  returned). The st_size stat-member contains the uncompressed size. 
  The optional d_name is never set here. For a real file, we do set the
  d_csize := st_size and d_compr := 0 for meaningful defaults.
</p>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_strerror">zzip_strerror</a></b>(int errcode)
 : zzip_char_t *
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_strerror_of">zzip_strerror_of</a></b>(ZZIP_DIR * dir)
 : zzip_char_t *
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/err.c</small></em></td></table>
</td></tr><tr><td valign="top"><p>  The <code>zzip_strerror_of</code> function fetches the errorcode from the <code>DIR-handle</code> and 
  runs it through <code><a href="#zzip_strerror">zzip_strerror</a></code> to obtain the static string
  describing the error.
</p>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_dir_open">zzip_dir_open</a></b>(zzip_char_t * filename, zzip_error_t * e)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_dir_open_ext_io">zzip_dir_open_ext_io</a></b>(zzip_char_t * filename, zzip_error_t * e,
                     zzip_strings_t * ext, zzip_plugin_io_t io)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_dir_read">zzip_dir_read</a></b>(ZZIP_DIR * dir, ZZIP_DIRENT * d)
 : int
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/zip.c</small></em></td></table>
</td></tr><tr><td valign="top"><p>  the <code>zzip_dir_open_ext_io</code> function uses explicit ext and io instead of the internal
  defaults. Setting these to zero is equivalent to <code><a href="#zzip_dir_open">zzip_dir_open</a></code>
  Note that the referenced ext_io plugin handlers structure must be 
  static as it is not copied to the returned ZZIP_DIR structure.
</p>
</td></tr><tr><td valign="top"><p>  fills the dirent-argument with the values and
  increments the read-pointer of the dir-argument.
</p><p>
  returns 0 if there no entry (anymore).
</p>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_init_io">zzip_init_io</a></b>(zzip_plugin_io_handlers_t io, int flags)
 : int
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_get_default_io">zzip_get_default_io</a></b>(void)
 : zzip_plugin_io_t
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/plugin.c</small></em></td></table>
</td></tr><tr><td valign="top"><p>  The <code>zzip_get_default_io</code> function returns a zzip_plugin_io_t handle to static defaults
  wrapping the posix io file functions for actual file access. The
  returned structure is shared by all threads in the system.
</p>
</td></tr></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_rewinddir">zzip_rewinddir</a></b>(ZZIP_DIR * dir)
 : void
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_telldir">zzip_telldir</a></b>(ZZIP_DIR * dir)
 : zzip_off_t
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_seekdir">zzip_seekdir</a></b>(ZZIP_DIR * dir, zzip_off_t offset)
 : void
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_telldir32">zzip_telldir32</a></b>(ZZIP_DIR * dir)
 : long
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_seekdir32">zzip_seekdir32</a></b>(ZZIP_DIR * dir, long offset)
 : void
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em> </em> </td><td align="right"> <em><small>zzip/dir.c</small></em></td></table><p>  The <code>zzip_rewinddir</code> function is the equivalent of a <a href="http://www.opengroup.org/onlinepubs/000095399/functions/rewinddir.html"><code>rewinddir(2)</code></a> for a realdir or
  the zipfile in place of a directory. The ZZIP_DIR handle returned from
  <code><a href="#zzip_opendir">zzip_opendir</a></code> has a flag saying realdir or zipfile. As for a zipfile,
  the filenames will include the filesubpath, so take care.
</p>
</td></tr><tr><td valign="top"><p>  The <code>zzip_telldir</code> function is the equivalent of <a href="http://www.opengroup.org/onlinepubs/000095399/functions/telldir.html"><code>telldir(2)</code></a> for a realdir or zipfile.
</p>
</td></tr><tr><td valign="top"><p>  The <code>zzip_seekdir</code> function is the equivalent of <a href="http://www.opengroup.org/onlinepubs/000095399/functions/seekdir.html"><code>seekdir(2)</code></a> for a realdir or zipfile.
</p>
</td></tr><tr><td valign="top"><p>  The <code>zzip_telldir32</code> function is provided for users who can not use any largefile-mode.
</p>
</td></tr><tr><td valign="top"><p>  The <code>zzip_seekdir32</code> function is provided for users who can not use any largefile-mode.
</p>
</td></tr></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_fopen">zzip_fopen</a></b>(zzip_char_t * filename, zzip_char_t * mode)
 : ZZIP_FILE *
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_freopen">zzip_freopen</a></b>(zzip_char_t * filename, zzip_char_t * mode, ZZIP_FILE * stream)
 : ZZIP_FILE *
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>                                                          </em> </td><td align="right"> <em><small>zzip/file.c</small></em></td></table><p>  The <code>zzip_fopen</code> function will <a href="http://www.opengroup.org/onlinepubs/000095399/functions/fopen.html"><code>fopen(3)</code></a> a real/zipped file.
</p><p>
  It has some magic functionality builtin - it will first try to open
  the given <em>filename</em> as a normal file. If it does not
  exist, the given path to the filename (if any) is split into
  its directory-part and the file-part. A ".zip" extension is
  then added to the directory-part to create the name of a
  zip-archive. That zip-archive (if it exists) is being searched
  for the file-part, and if found a zzip-handle is returned.
</p><p>
  Note that if the file is found in the normal fs-directory the
  returned structure is mostly empty and the <code><a href="#zzip_read">zzip_read</a></code> call will
  use the libc <a href="http://www.opengroup.org/onlinepubs/000095399/functions/read.html"><code>read(2)</code></a> to obtain data. Otherwise a <code><a href="#zzip_file_open">zzip_file_open</a></code>
  is performed and any error mapped to <a href="http://www.opengroup.org/onlinepubs/000095399/functions/errno.html"><code>errno(3)</code></a>.
</p><p>
  unlike the posix-wrapper <code><a href="#zzip_open">zzip_open</a></code> the mode-argument is
  a string which allows for more freedom to support the extra
  zzip modes called ZZIP_CASEINSENSITIVE and ZZIP_IGNOREPATH.
  Currently, this <code><a href="#zzip_fopen">zzip_fopen</a></code> call will convert the following
  characters in the mode-string into their corrsponding mode-bits:
</p><ul><li><p> <code> "r" : O_RDONLY : </code> read-only </p></li>
<li><p> <code> "b" : O_BINARY : </code> binary (win32 specific) </p></li>
<li><p> <code> "f" : O_NOCTTY : </code> no char device (unix) </p></li>
<li><p> <code> "i" : ZZIP_CASELESS : </code> inside zip file </p></li>
<li><p> <code> "*" : ZZIP_NOPATHS : </code> inside zip file only </p></li>
</ul><p>  all other modes will be ignored for zip-contained entries
  but they are transferred for compatibility and portability,
  including these extra sugar bits:
</p><ul><li><p> <code> "x" : O_EXCL :</code> fail if file did exist </p></li>
<li><p> <code> "s" : O_SYNC :</code> synchronized access </p></li>
<li><p> <code> "n" : O_NONBLOCK :</code> nonblocking access </p></li>
<li><p> <code> "z#" : compression level :</code> for zlib </p></li>
<li><p> <code> "g#" : group access :</code> unix access bits </p></li>
<li><p> <code> "u#" : owner access :</code> unix access bits </p></li>
<li><p> <code> "o#" : world access :</code> unix access bits </p></li>
</ul><p>  ... the access bits are in traditional unix bit format
  with 7 = read/write/execute, 6 = read/write, 4 = read-only.
</p><p>
  The default access mode is 0664, and the compression level
  is ignored since the lib can not yet write zip files, otherwise
  it would be the initialisation value for the zlib deflateInit
  where 0 = no-compression, 1 = best-speed, 9 = best-compression.
</p><p>
  The <code>zzip_fopen</code> function returns a new zzip-handle (use <code><a href="#zzip_close">zzip_close</a></code> to return
  it). On error the <code>zzip_fopen</code> function will return null setting <a href="http://www.opengroup.org/onlinepubs/000095399/functions/errno.html"><code>errno(3)</code></a>.
</p>
</td></tr><tr><td valign="top"><p>
  The <code>zzip_freopen</code> function receives an additional argument pointing to
  a ZZIP_FILE* being already in use. If this extra argument is
  null then the <code>zzip_freopen</code> function is identical with calling <code><a href="#zzip_fopen">zzip_fopen</a></code>
</p><p>
  Per default, the old file stream is closed and only the internal
  structures associated with it are kept. These internal structures
  may be reused for the return value, and this is a lot quicker when
  the filename matches a zipped file that is incidently in the very
  same zip arch as the old filename wrapped in the stream struct.
</p><p>
  That's simply because the zip arch's central directory does not
  need to be read again. As an extension for the <code>zzip_freopen</code> function, if the
  mode-string contains a "q" then the old stream is not closed but
  left untouched, instead it is only given as a hint that a new
  file handle may share/copy the zip arch structures of the old file
  handle if that is possible, i.e when they are in the same zip arch.
</p><p>
  The <code>zzip_freopen</code> function returns a new zzip-handle (use <code><a href="#zzip_close">zzip_close</a></code> to return
  it). On error the <code>zzip_freopen</code> function will return null setting <a href="http://www.opengroup.org/onlinepubs/000095399/functions/errno.html"><code>errno(3)</code></a>.
</p>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_dirhandle">zzip_dirhandle</a></b>(ZZIP_FILE * fp)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_dirfd">zzip_dirfd</a></b>(ZZIP_DIR * dir)
 : int
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/info.c</small></em></td></table>
</td></tr><tr><td valign="top"><p>   The <code>zzip_dirfd</code> function will just return dir->fd
</p><p>
  If a ZZIP_DIR does point to a zipfile then the file-descriptor of that
  zipfile is returned, otherwise a NULL is returned and the ZZIP_DIR wraps
  a real directory DIR (if you have dirent on your system).
</p>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_seek">zzip_seek</a></b>(ZZIP_FILE * fp, zzip_off_t offset, int whence)
 : zzip_off_t
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_seek32">zzip_seek32</a></b>(ZZIP_FILE * fp, long offset, int whence)
 : long
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/file.c</small></em></td></table>
</td></tr><tr><td valign="top"><p>  The <code>zzip_seek32</code> function is provided for users who can not use any largefile-mode.
</p>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_read">zzip_read</a></b>(ZZIP_FILE * fp, void *buf, zzip_size_t len)
 : zzip_ssize_t
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_fread">zzip_fread</a></b>(void *ptr, zzip_size_t size, zzip_size_t nmemb, ZZIP_FILE * file)
 : zzip_size_t
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/file.c</small></em></td></table>
</td></tr><tr><td valign="top">
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_dir_free">zzip_dir_free</a></b>(ZZIP_DIR * dir)
 : int
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_dir_close">zzip_dir_close</a></b>(ZZIP_DIR * dir)
 : int
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/zip.c</small></em></td></table>
</td></tr><tr><td valign="top"><p>  It will also <a href="http://www.opengroup.org/onlinepubs/000095399/functions/free.html"><code>free(2)</code></a> the <code>ZZIP_DIR-handle</code> given.
  the counterpart for <code><a href="#zzip_dir_open">zzip_dir_open</a></code>
  see also <code><a href="#zzip_dir_free">zzip_dir_free</a></code>
</p>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_fclose">zzip_fclose</a></b>(ZZIP_FILE * fp)
 : int
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_close">zzip_close</a></b>(ZZIP_FILE * fp)
 : int
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/file.c</small></em></td></table>
</td></tr><tr><td valign="top">
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_dir_fdopen">zzip_dir_fdopen</a></b>(int fd, zzip_error_t * errcode_p)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_dir_fdopen_ext_io">zzip_dir_fdopen_ext_io</a></b>(int fd, zzip_error_t * errcode_p,
                       zzip_strings_t * ext, const zzip_plugin_io_t io)
 : ZZIP_DIR *
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/zip.c</small></em></td></table>
</td></tr><tr><td valign="top"><p>  the <code>zzip_dir_fdopen_ext_io</code> function uses explicit ext and io instead of the internal
  defaults, setting these to zero is equivalent to <code><a href="#zzip_dir_fdopen">zzip_dir_fdopen</a></code>
</p>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_dir_alloc_ext_io">zzip_dir_alloc_ext_io</a></b>(zzip_strings_t * ext, const zzip_plugin_io_t io)
 : ZZIP_DIR *
</code></td></tr><tr><td valign="top"><code><b><a name="zzip_dir_alloc">zzip_dir_alloc</a></b>(zzip_strings_t * fileext)
 : ZZIP_DIR *
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/zip.c</small></em></td></table>
</td></tr><tr><td valign="top"><p>  the <code>zzip_dir_alloc</code> function is obsolete - it was generally used for implementation
  and exported to let other code build on it. It is now advised to
  use <code><a href="#zzip_dir_alloc_ext_io">zzip_dir_alloc_ext_io</a></code> now on explicitly, just set that second
  argument to zero to achieve the same functionality as the old style.
</p>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_readdir">zzip_readdir</a></b>(ZZIP_DIR * dir)
 : ZZIP_DIRENT *
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/dir.c</small></em></td></table>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_closedir">zzip_closedir</a></b>(ZZIP_DIR * dir)
 : int
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/dir.c</small></em></td></table>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_errno">zzip_errno</a></b>(int errcode)
 : int
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/err.c</small></em></td></table>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_file_close">zzip_file_close</a></b>(ZZIP_FILE * fp)
 : int
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/file.c</small></em></td></table>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_file_open">zzip_file_open</a></b>(ZZIP_DIR * dir, zzip_char_t * name, int o_mode)
 : ZZIP_FILE *
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/file.c</small></em></td></table>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_inflate_init">zzip_inflate_init</a></b>(ZZIP_FILE * fp, struct zzip_dir_hdr *hdr)
 : static int
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/file.c</small></em></td></table>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_file_read">zzip_file_read</a></b>(ZZIP_FILE * fp, void *buf, zzip_size_t len)
 : zzip_ssize_t
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/file.c</small></em></td></table>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_rewind">zzip_rewind</a></b>(ZZIP_FILE * fp)
 : int
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/file.c</small></em></td></table>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="zzip_compr_str">zzip_compr_str</a></b>(int compr)
 : zzip_char_t *
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/info.c</small></em></td></table>
</td></tr></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="__zzip_fetch_disk_trailer">__zzip_fetch_disk_trailer</a></b>(int fd, zzip_off_t filesize,
                          struct _disk_trailer *_zzip_restrict trailer,
                          zzip_plugin_io_t io)
 : int
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/zip.c</small></em></td></table>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="__zzip_parse_root_directory">__zzip_parse_root_directory</a></b>(int fd,
                            struct _disk_trailer *trailer,
                            struct zzip_dir_hdr **hdr_return,
                            zzip_plugin_io_t io)
 : int
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/zip.c</small></em></td></table>
</td></tr></table></dd><dt><table width="100%"><tr><td valign="top"><code><b><a name="__zzip_try_open">__zzip_try_open</a></b>(zzip_char_t * filename, int filemode,
                zzip_strings_t * ext, zzip_plugin_io_t io)
 : int
</code></td></tr></table></dt><dd><table width="100%"><tr><td valign="top"><table border="0" width="100%" cellpadding="0" cellspacing="0"><td> &nbsp;<em>...</em> </td><td align="right"> <em><small>zzip/zip.c</small></em></td></table>
</td></tr></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd><dt><table width="100%"></table></dt><dd><table width="100%"></table></dd></dl>
</body></html>
